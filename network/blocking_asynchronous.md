# Blocking, Non-blocking I/O
### I/O 작업
- i/o 작업은 User level 에서 직접 수행할 수 없다.
- i/o 작업은 `Kernel level`에서만 수행할 수 있다.
- 즉, 유저 프로세스는 `커널에게 i/o 작업을 요청`하고, 작업이 완료되어 커널이 반환하는 결과를 `기다려야`한다.

## Blocking I/O 란?
- I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한채 대기하는 방식
	- cpu의 기본적인 i/o 모델: Blocking I/O Model
- 리눅스에서 모든 소켓 통신은 blocking으로 기본 동작한다.
- 애플리케이션에서 다른 작업을 수행하지 못한 채 대기하므로, 자원이 낭비된다.

#### 진행 순서
1. 유저가 커널에게 read 작업을 요청한다.
2. 데이터가 입력될 때까지 대기한다.
3. 데이터가 입력되면, 커널 모드에서 유저모드로 데이터를 복사한다.

## Non-Blocking I/O 란?
- I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단하지 않는 방식
- 즉, I/O 진행시간과 관계가 없기에, 애플리케이션에서 작업을 중지하지 않고도 I/O 작업을 진행할 수 있다.
- 반복적으로 시스템호출이 발생하기 때문에 자원이 낭비된다.

#### 진행 순서
1. 유저가 커널에게 read 작업을 요청한다.
2. 작업을 요청하는 순간, 바로 데이터가 반환된다.
	- 만약 입력 데이터가 없다면, 그를 나타내는 EWOULDBLOCK을 반환한다.
3. 입력 데이터가 있을때까지 앞 과정을 반복한다.
4. 입력 데이터가 있으면, 커널 모드에서 유저모드로 데이터를 복사한다.


# 동기식 I/O, 비동기식 I/O
## 동기식(Synchronous) I/O 란?
- I/O 작업이 진행되는 동안 유저 프로세스는 결과를 기다렸다가 이벤트(결과)를 직접 처리하는 방식
	- 이때 유저 프로세스는 blocking 방식처럼 다 될때까지 기다릴수도, 혹은 non-blocking처럼 커널에 계속 요청하며 기다릴 수도 있다.
	- 결론적으로는 계속 기다린다는것.
- 즉, notify를 `유저 프로세스가 담당`하여 주체적으로 진행하며, `커널은 유저프로세스의 요청에 수동적으로 응답`하는 것이다.

## 비동기식(Asynchronous) I/O 란?
- I/O 작업이 진행되는 동안에도 유저 프로세스는 영향 없이 계속 자신의 작업을 진행한다. 이벤트 핸들러에 의해 알람이 오면 그때 처리한다.
- 즉, notify를 `커널이 담당`하여 주체적으로 진행하며, `유저프로세스는 수동적`으로 notify가 오면 그때 I/O를 처리하는 것이다.

# 정리하며
즉, blocking 과 non-blocking은 `제어권`이 누구에게 있는지에 대한 차이가 있으며,
synchronous와 asynchronous는 일을 수행하는 `동시성`에 차이가 있는 것이다.

##### [참고 아티클](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC )
